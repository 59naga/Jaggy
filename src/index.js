// Generated by CoffeeScript 1.9.0
var Jaggy, describe,
  __slice = [].slice;

Jaggy = function() {
  var args, options;
  options = arguments[0], args = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
  if (args.length === 0) {
    return Jaggy.gulpPlugin(options);
  }
};

describe = (require('debug'))('jaggy');

Jaggy.gulpPlugin = function(options) {
  var gutil, through2;
  if (options == null) {
    options = {};
  }
  gutil = require('gulp-util');
  through2 = require('through2');
  return through2.obj(function(file, encode, next) {
    if (file.isStream()) {
      return this.emit('error', new gutil.PluginError('jaggy', 'Streaming not supported'));
    }
    describe('Convert to pixelArray by Image');
    return Jaggy.readImageData(file, (function(_this) {
      return function(error, pixels) {
        var palette, svg;
        if (error != null) {
          throw error;
        }
        describe('Convert to Palette by pixelArray');
        palette = Jaggy.convert(pixels, options);
        describe('Create <svg> by Palette');
        svg = palette.toSVG(options);
        if (typeof options.afterConvert === 'function') {
          svg = options.afterConvert(svg, palette, file);
        }
        file.path = gutil.replaceExtension(file.path, '.svg');
        file.contents = new Buffer(svg.outerHTML.replace(' viewbox=', ' viewBox='));
        _this.push(file);
        return next();
      };
    })(this));
  });
};

Jaggy.readImageData = function(file, callback) {
  var getPixels, mime, mimeType;
  if (typeof file !== 'object') {
    return callback('file is not object');
  }
  mime = require('mime');
  mimeType = mime.lookup(file.path);
  getPixels = require('get-pixels');
  return getPixels(new Buffer(file.contents), mimeType, callback);
};

Jaggy.convert = function(imagedata, options) {
  var channels, height, i, increment, palette, rgba, values, width, x, y, _ref;
  if (options == null) {
    options = {};
  }
  if (imagedata.shape.length === 4) {
    throw new Error('AnimationGif is not supported. Coming soon.');
  }
  if (imagedata.width === void 0) {
    _ref = imagedata.shape, width = _ref[0], height = _ref[1], channels = _ref[2];
    imagedata.width = width;
    imagedata.height = height;
  }
  palette = new Jaggy.Palette(imagedata.width, imagedata.height);
  i = 0;
  increment = options.glitch ? options.glitch : 4;
  while (imagedata.data[i] !== void 0) {
    if (imagedata.data[i + 3] !== 0) {
      values = [];
      values.push(imagedata.data[i + 0]);
      values.push(imagedata.data[i + 1]);
      values.push(imagedata.data[i + 2]);
      values.push((imagedata.data[i + 3] / 255).toFixed(2));
      rgba = 'rgba(' + values.join(',') + ')';
      if (palette[rgba] === void 0) {
        palette[rgba] = new Jaggy.Color;
      }
      x = (i / 4) % imagedata.width;
      y = ~~((i / 4) / imagedata.width);
      palette[rgba].put(new Jaggy.Point(x, y));
    }
    i = typeof increment === 'function' ? increment(i) : i + increment;
  }
  return palette;
};

Jaggy.Palette = (function() {
  function Palette(_at_width, _at_height, _at_attrs) {
    var _base, _base1, _base2, _base3, _base4, _base5, _base6;
    this.width = _at_width;
    this.height = _at_height;
    this.attrs = _at_attrs != null ? _at_attrs : {};
    if ((_base = this.attrs)['shape-rendering'] == null) {
      _base['shape-rendering'] = 'crispEdges';
    }
    if ((_base1 = this.attrs)['version'] == null) {
      _base1['version'] = '1.1';
    }
    if ((_base2 = this.attrs)['xmlns'] == null) {
      _base2['xmlns'] = 'http://www.w3.org/2000/svg';
    }
    if ((_base3 = this.attrs)['xmlns:xlink'] == null) {
      _base3['xmlns:xlink'] = 'http://www.w3.org/1999/xlink';
    }
    if ((_base4 = this.attrs)['viewBox'] == null) {
      _base4['viewBox'] = "0 0 " + this.width + " " + this.height;
    }
    if ((_base5 = this.attrs)['width'] == null) {
      _base5['width'] = this.width;
    }
    if ((_base6 = this.attrs)['height'] == null) {
      _base6['height'] = this.height;
    }
  }

  Palette.prototype.toSVG = function(options) {
    var dom, key, svg, value, _ref;
    if (options == null) {
      options = {};
    }
    dom = typeof document !== "undefined" && document !== null ? document : require('dom-lite').document;
    svg = dom.createElement('svg');
    _ref = this.attrs;
    for (key in _ref) {
      value = _ref[key];
      svg.setAttribute(key, value);
    }
    svg.appendChild(this.toG(options));
    return svg;
  };

  Palette.prototype.toG = function(options) {
    var color, dom, g, rgba;
    if (options == null) {
      options = {};
    }
    dom = typeof document !== "undefined" && document !== null ? document : require('dom-lite').document;
    g = dom.createElement('g');
    for (rgba in this) {
      color = this[rgba];
      if (color instanceof Jaggy.Color) {
        g.appendChild(color.toPath(rgba, options));
      }
    }
    return g;
  };

  return Palette;

})();

Jaggy.Color = (function() {
  function Color(_at_points) {
    this.points = _at_points != null ? _at_points : [];
  }

  Color.prototype.put = function(point) {
    return this.points.push(point);
  };

  Color.prototype.toPath = function(fill, options) {
    var dom, path;
    if (fill == null) {
      fill = 'black';
    }
    if (options == null) {
      options = {};
    }
    dom = typeof document !== "undefined" && document !== null ? document : require('dom-lite').document;
    path = dom.createElement('path');
    if (fill.length) {
      path.setAttribute('fill', fill);
    }
    if (this.points.length) {
      path.setAttribute('d', this.getRects(options).map(function(rect) {
        return rect.toD();
      }).join(''));
    }
    return path;
  };

  Color.prototype.getRects = function(options) {
    var is_left, left, point, rects, _i, _len, _ref;
    if (options == null) {
      options = {};
    }
    rects = [];
    _ref = this.points;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      point = _ref[_i];
      left = rects[rects.length - 1] || {};
      is_left = left.y === point.y && (left.x + left.width) === point.x;
      if (is_left && options.fullPixel !== true) {
        left.width++;
        continue;
      }
      rects.push(point.toRect(options));
    }
    return rects;
  };

  return Color;

})();

Jaggy.Rect = (function() {
  function Rect(point) {
    this.x = point.x;
    this.y = point.y;
    this.width = 1;
    this.height = 1;
  }

  Rect.prototype.toD = function() {
    return 'M' + this.x + ',' + this.y + 'h' + this.width + 'v' + this.height + 'h-' + this.width + 'Z';
  };

  return Rect;

})();

Jaggy.Point = (function() {
  function Point(_at_x, _at_y) {
    this.x = _at_x;
    this.y = _at_y;
  }

  Point.prototype.toRect = function(options) {
    if (options == null) {
      options = {};
    }
    return new Jaggy.Rect(this);
  };

  return Point;

})();

module.exports = Jaggy;
