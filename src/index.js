// Generated by CoffeeScript 1.8.0
var Jaggy, debug,
  __slice = [].slice;

Jaggy = function() {
  var args, options;
  options = arguments[0], args = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
  if (args.length === 0) {
    return Jaggy.gulpPlugin(options);
  }
};

debug = (require('debug'))('vectorizer');

Jaggy.gulpPlugin = function(options) {
  var gutil, through2;
  if (options == null) {
    options = {};
  }
  gutil = require('gulp-util');
  through2 = require('through2');
  return through2.obj(function(file, encode, next) {
    var getPixels, isGulpBuffer, mime, mimeType, self;
    if (file.isStream()) {
      return this.emit('error', new gutil.PluginError('gulp-vectorizer', 'Streaming not supported'));
    }
    self = this;
    isGulpBuffer = typeof file === 'object';
    if (isGulpBuffer) {
      mime = require('mime');
      mimeType = mime.lookup(file.path);
      debug('convet to pixelArray by Image');
      getPixels = require('get-pixels');
      return getPixels(new Buffer(file.contents), mimeType, function(error, pixels) {
        var colors, dom, g, key, paths, svg, svgAttrs, svgHTML, value;
        if (error != null) {
          throw error;
        }
        debug('convert to colors by pixelArray');
        colors = Jaggy.convert(pixels, options);
        debug('create svg by colors');
        dom = typeof document !== "undefined" && document !== null ? document : require('dom-lite').document;
        svg = dom.createElement('svg');
        svgAttrs = {
          "shape-rendering": "crispEdges",
          "version": "1.1",
          "xmlns": "http://www.w3.org/2000/svg",
          "xmlns:xlink": "http://www.w3.org/1999/xlink",
          "viewBox": "0 0 " + colors.width + " " + colors.height,
          "width": colors.width,
          "height": colors.height
        };
        for (key in svgAttrs) {
          value = svgAttrs[key];
          svg.setAttribute(key, value);
        }
        g = dom.createElement('g');
        paths = colors.toPaths(options);
        paths.forEach(function(pathAttrs) {
          var path;
          path = dom.createElement('path');
          for (key in pathAttrs) {
            value = pathAttrs[key];
            path.setAttribute(key, value);
          }
          return g.appendChild(path);
        });
        svg.appendChild(g);
        if (typeof options.afterConvert === 'function') {
          svg = options.afterConvert(svg, colors, file);
        }
        debug('emit Buffer');
        svgHTML = svg.outerHTML.replace(' viewbox=', ' viewBox=');
        file.path = gutil.replaceExtension(file.path, '.svg');
        file.contents = new Buffer(svgHTML);
        self.push(file);
        return next();
      });
    }
  });
};

Jaggy.convert = function(imagedata, options) {
  var channels, colors, height, i, increment, rgba, values, width, x, y, _ref;
  if (options == null) {
    options = {};
  }
  if (imagedata.shape.length === 4) {
    throw new Error('AnimationGif is not supported. Coming soon.');
  }
  if (imagedata.width === void 0) {
    _ref = imagedata.shape, width = _ref[0], height = _ref[1], channels = _ref[2];
    imagedata.width = width;
    imagedata.height = height;
  }
  colors = new Jaggy.Colors(imagedata.width, imagedata.height);
  i = 0;
  increment = options.glitch ? options.glitch : 4;
  while (imagedata.data[i] !== void 0) {
    if (imagedata.data[i + 3] !== 0) {
      values = [];
      values.push(imagedata.data[i + 0]);
      values.push(imagedata.data[i + 1]);
      values.push(imagedata.data[i + 2]);
      values.push((imagedata.data[i + 3] / 255).toFixed(2));
      rgba = 'rgba(' + values.join(',') + ')';
      if (colors[rgba] === void 0) {
        colors[rgba] = new Jaggy.Color;
      }
      x = (i / 4) % imagedata.width;
      y = ~~((i / 4) / imagedata.width);
      colors[rgba].put(new Jaggy.Point(x, y));
    }
    i = typeof increment === 'function' ? increment(i) : i + increment;
  }
  return colors;
};

Jaggy.Colors = (function() {
  function Colors(width, height) {
    this.width = width;
    this.height = height;
  }

  Colors.prototype.toPaths = function(options) {
    var color, paths, rgba;
    if (options == null) {
      options = {};
    }
    paths = [];
    for (rgba in this) {
      color = this[rgba];
      if (typeof color === 'object') {
        paths.push(color.toPath(rgba, options));
      }
    }
    return paths;
  };

  return Colors;

})();

Jaggy.Color = (function() {
  function Color(points) {
    this.points = points != null ? points : [];
  }

  Color.prototype.put = function(color) {
    return this.points.push(color);
  };

  Color.prototype.toPath = function(fill, options) {
    var path;
    if (fill == null) {
      fill = 'black';
    }
    if (options == null) {
      options = {};
    }
    path = {};
    path.fill = fill;
    path.d = this.toRects(options).map(function(rect) {
      return rect.toD();
    }).join('');
    return path;
  };

  Color.prototype.toRects = function(options) {
    var is_left, left, point, rects, _i, _len, _ref;
    if (options == null) {
      options = {};
    }
    rects = [];
    _ref = this.points;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      point = _ref[_i];
      left = rects[rects.length - 1] || {};
      is_left = left.y === point.y && (left.x + left.width) === point.x;
      if (is_left && options.fullPixel !== true) {
        left.width++;
        continue;
      }
      rects.push(new Jaggy.Rect(point));
    }
    return rects;
  };

  return Color;

})();

Jaggy.Rect = (function() {
  function Rect(point) {
    this.x = point.x;
    this.y = point.y;
    this.width = 1;
    this.height = 1;
  }

  Rect.prototype.toD = function() {
    return 'M' + this.x + ',' + this.y + 'h' + this.width + 'v' + this.height + 'h-' + this.width + 'Z';
  };

  return Rect;

})();

Jaggy.Point = (function() {
  function Point(x, y) {
    this.x = x;
    this.y = y;
  }

  return Point;

})();

module.exports = Jaggy;
